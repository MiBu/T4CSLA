<#@ template language="C#" debug="true" hostspecific="true"#>
<#@ include file="EF.Utility.CS.ttinclude"#>
<#@ output extension=".cs"#>

<#

UserSettings userSettings =
        new UserSettings
        {
            SourceCsdlPath = @"NorthwindModel.edmx",
			LibraryNamespace = "CslaT4.Library",
			DataNamespace = "CslaT4.Library.Data",
            ReferenceCsdlPaths = new string[] {},
            FullyQualifySystemTypes = false,
            CreateContextAddToMethods = true,
            CamelCaseFields = false,
        };

ApplyUserSettings(userSettings);
if(Errors.HasErrors)
{
    return String.Empty;
}

MetadataLoader loader = new MetadataLoader(this);
MetadataTools ef = new MetadataTools(this);
CodeRegion region = new CodeRegion(this);
CodeGenerationTools code = new CodeGenerationTools(this){FullyQualifySystemTypes = userSettings.FullyQualifySystemTypes, CamelCaseFields = userSettings.CamelCaseFields};

ItemCollection = loader.CreateEdmItemCollection(SourceCsdlPath, ReferenceCsdlPaths.ToArray());
ModelNamespace = loader.GetModelNamespace(SourceCsdlPath);
string namespaceName = userSettings.LibraryNamespace;//code.VsNamespaceSuggestion() ?? GetObjectNamespace(ModelNamespace);
UpdateObjectNamespaceMap(namespaceName);
#>


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using <#=userSettings.DataNamespace#>;
using Csla;
using Csla.Data;

<#
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>

namespace <#=namespaceName#>
{
<#
        PushIndent(CodeRegion.GetIndent(1));
    }

	IEnumerable<AssociationType> associations = GetSourceSchemaTypes<AssociationType>().Where(i => i is AssociationType);
	foreach (AssociationType item in associations)
	{

	}

	
	EntityContainer container = null;
    foreach (EntityContainer c in GetSourceSchemaTypes<EntityContainer>())
    {
		container = c;
		break;
	}


	
    ////////
    //////// Write Entities
    ////////
    region.Begin(GetResourceString("Template_RegionEntities"));
    foreach (EntityType entity in GetSourceSchemaTypes<EntityType>().OrderBy(e => e.Name))
    {
		if (entity.Documentation == null || entity.Documentation.Summary == string.Empty)
				continue;
		foreach (string cslaTypeName in entity.Documentation.Summary.Split(';'))
		{
			CslaType cslaType= GetCslaType(cslaTypeName);
			string entityName = getEntityName(entity, code); 
			string listName = getListName(entity, code); 
			string dataFullName = string.Format("{0}.{1}", userSettings.DataNamespace, code.Escape(entity));
			string containerFullName = string.Format("{0}.{1}", userSettings.DataNamespace, container.Name);
			bool child = IsChild(cslaType);
			bool root = !child;
			bool readOnly = IsReadOnly(cslaType);
			
			if (!IsList(cslaType))
			{
				
#>
[Serializable]
<#=Accessibility.ForType(entity)#> <#=code.SpaceAfter(code.AbstractOption(entity))#>partial class <#=entityName#>  : <#=GetBaseTypeName(entity, cslaType, code) #>
{
<#
		//If is ROOT object and primary key is not null generate criteria for Get by primary key method
		if (root && entity.KeyMembers.Count > 0)
		{
			region.Begin("KeyCriteria");
			WriteKeyCriteria(entity, code);	
			region.End();
		}
		

        region.Begin("Simple properties");
		
        foreach (EdmProperty property in entity.Properties.Where(p => p.DeclaringType == entity && p.TypeUsage.EdmType is PrimitiveType))
		{
			string propertyName = code.Escape(property);
			string propertyType = code.Escape(property.TypeUsage);
			WriteRegisterProperty(propertyName, propertyType, code);
            VerifyGetterAndSetterAccessibilityCompatability(property);
            WritePrimitiveTypeProperty(property, readOnly, code);
        }
		
        region.End();

		
        region.Begin("Navigation properties");
        foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(n => n.DeclaringType == entity))
        {
			if (navProperty.Documentation == null)
				continue;
			EntityType navEntity = navProperty.ToEndMember.GetEntityType();
			if (navEntity.Documentation != null && navEntity.Documentation.Summary != string.Empty)
			{
				string navEntityType = string.Empty;
				if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
					navEntityType = getListName(navEntity, code);
				else
					navEntityType = getEntityName(navEntity, code);
				string navPropertyName = code.Escape(navProperty);
				WriteRegisterProperty(navPropertyName, navEntityType, code);
				WriteNavigationProperty(navProperty, readOnly, code);
			}
        }
		
        region.End();

		
		//Factory methods
		region.Begin("Factory Methods");
		
		
#>
	<#= GetFactoryMethodAccessibility(cslaType) #> static <#=entityName#>  New()
	{
		return <#=GetFactoryMethodName("Create", cslaType)#><<#=entityName#>>();
	}
	
<#
		
		if (root && entity.KeyMembers.Count > 0)
		{
#>

	<#= GetFactoryMethodAccessibility(cslaType) #> static <#=entityName#> Get(<# WriteKeyParametersWithTypes(entity, code); #>)
    {
    	return <#=GetFactoryMethodName("Fetch", cslaType)#><<#=entityName#>>(new KeyCriteria(<# WriteKeyParameters(entity, code); #>));
	}
<#
		}
#>

    internal static <#=entityName#> Get(<#=dataFullName#> data)
    {
		if (data == null)
			return null;
    	return <#=GetFactoryMethodName("Fetch", cslaType)#><<#=entityName#>>(data);
	}

<#
        region.End();

		
		
		region.Begin("DataAccess - Read");
#>
	private void readData(<#=dataFullName#> data)
	{
		BeforeDataRead(data);
<#
        foreach (EdmProperty property in entity.Properties.Where(p => p.DeclaringType == entity && p.TypeUsage.EdmType is PrimitiveType))
        {
			WriteLoadProperty(property, code);
        }
		
		foreach (NavigationProperty navProperty in entity.NavigationProperties.Where(n => n.DeclaringType == entity))
		{
			if (navProperty.Documentation == null)
				continue;
			EntityType navEntity = navProperty.ToEndMember.GetEntityType();
			if (navEntity.Documentation != null && navEntity.Documentation.Summary != string.Empty)
			{
				string navEntityType = string.Empty;
				if (navProperty.ToEndMember.RelationshipMultiplicity == RelationshipMultiplicity.Many)
					navEntityType = getListName(navEntity, code);
				else
					navEntityType = getEntityName(navEntity, code);
				string navPropertyName = code.Escape(navProperty);
#>
		if (data.<#= navProperty.Name #> != null)
		{
			LoadProperty(<#= navPropertyName #>Property, <#= navEntityType #>.Get(data.<#= navProperty.Name #>));
		}
<#

			}

		}
#>
		AfterDataRead(data);
	}
	partial void BeforeDataRead(<#=dataFullName#> data);
    partial void AfterDataRead(<#=dataFullName#> data);

<#

        region.End();

		if (!readOnly)
		{
		region.Begin("DataAccess - Write");
#>
	private void writeData(<#=userSettings.DataNamespace +"." + code.Escape(entity)#> data)
	{
		BeforeDataWrite(data);
<#
        foreach (EdmProperty property in entity.Properties.Where(p => p.DeclaringType == entity && p.TypeUsage.EdmType is PrimitiveType))
        {
			WriteReadProperty(property, code);
        }
#>
		AfterDataWrite(data);
	}
	partial void BeforeDataWrite(<#=dataFullName#> data);
    partial void AfterDataWrite(<#=dataFullName#> data);

<#

    	region.End();
		}
		
		if (!readOnly)
		{
		region.Begin("DataAccess - Create");
#>

	[RunLocal]
	protected override void <#= GetDataAccessMethodName("Create", cslaType) #>()
    {
		BeforeDataPortal_Create();
		ValidationRules.CheckRules();
		AfterDataPortal_Create();
	}

	partial void BeforeDataPortal_Create();
    partial void AfterDataPortal_Create();

<#

    	region.End();
		}
		
		region.Begin("DataAccess - Fetch");
		if (root && entity.KeyMembers.Count > 0)
		{
#>
        private void <#= GetDataAccessMethodName("Fetch", cslaType) #>(KeyCriteria criteria)
        {
            using (var entities = new <#= containerFullName #>())
            {
                var data = entities.<#=code.Escape(entity)#>.Single(e => <# WriteKeyQueryParameters(entity, code); #> );
                DataPortal_Fetch(data);
            }//using
        }
<#
		}
#>
        private void <#= GetDataAccessMethodName("Fetch", cslaType) #>(<#=dataFullName#> data)
        {
			BeforeFetch(data);
            readData(data);
			AfterFetch(data);
        }
		partial void BeforeFetch(<#=dataFullName#> data);
    	partial void AfterFetch(<#=dataFullName#> data);
<#

    	region.End();

		if (!readOnly)
		{
		region.Begin("DataAccess - Insert");
#>
        <#=GetDataAccessMethodSignature(cslaType) #> <#=GetDataAccessMethodName("Insert", cslaType) #>()
        {
            using (var entities = new <#= containerFullName #>())
            {
                var data = new  <#= dataFullName  #>();
				BeforeInsert(data);
				writeData(data);
                entities.<#=code.Escape(entity)#>.AddObject(data);
				entities.SaveChanges();
				BeforeInsertChildren(data);
				FieldManager.UpdateChildren(this);
				AfterInsert(data);
            }//using
        }

		partial void BeforeInsert(<#=dataFullName#> data);
    	partial void AfterInsert(<#=dataFullName#> data);
		partial void BeforeInsertChildren(<#=dataFullName#> data);

<#

    	region.End();

		region.Begin("DataAccess - Update");
#>
        <#=GetDataAccessMethodSignature(cslaType) #> <#= GetDataAccessMethodName("Update", cslaType) #>()
        {
            using (var entities = new <#= containerFullName #>())
            {
                var data = entities.<#=code.Escape(entity)#>.Single(e => <# WriteThisQueryParameters(entity, code); #> );
				BeforeUpdate(data);
				writeData(data);
				entities.SaveChanges();
				BeforeUpdateChildren(data);
				FieldManager.UpdateChildren(this);
				AfterUpdate(data);
            }//using
        }
		
		partial void BeforeUpdate(<#=dataFullName#> data);
    	partial void AfterUpdate(<#=dataFullName#> data);
		partial void BeforeUpdateChildren(<#=dataFullName#> data);

<#
    	region.End();
		}
		
		foreach (EdmProperty property in entity.Properties.Where(p => p.DeclaringType == entity && p.TypeUsage.EdmType is PrimitiveType))
		{
			if (property.Documentation != null && property.Documentation.Summary == "ToString")
			{
				string propertyName = code.Escape(property);
#>
	public override string ToString()
	{
		return <#= propertyName #>;
	}
<#
				break;
			}
        }

#>
	public override bool Equals(object obj)
    {
    	if (obj is <#= entityName #>)
		{
        	<#= entityName #> other = (<#= entityName #>)obj;
			if 
			(
<# 
				bool first = true;
				foreach (EdmProperty property in entity.KeyMembers)
		        {
						
#>
				<# if (!first) {#> && <# } #> this.<#= property.Name #> == other.<#= property.Name #>
<#
					first = false;
				}
#>
			) 
			return true;
			else 
				return false;
       }
       else
           return base.Equals(obj);
	}

<# 
			}
			
//CREATE LIST 	
else if (IsList(cslaType)) 
{
				
#>
[Serializable]
<#=Accessibility.ForType(entity)#> <#=code.SpaceAfter(code.AbstractOption(entity))#>partial class <#=listName#>  : <#=GetBaseTypeName(entity, cslaType, code) #>
{
<#
		region.Begin("Factory Methods");

#>
	internal static <#=listName#> New()
	{
    	return new <#=listName#>();
	}
<#
	if (!child)
	{
#>
	public static <#=listName#> Get()
	{
		return DataPortal.Fetch<<#=listName#>>();
	}				
<#
	} 
#>

	internal static <#=listName#> Get(IEnumerable<<#=dataFullName#>> dataSet)
	{
    	var childList = new <#=listName#>();
		childList.Fetch(dataSet);
		return childList;
	}				
<#
	    region.End();//Factory Methods
#>
	#region Data Access
<#
	if (!child)
	{
#>
	private void DataPortal_Fetch()
	{
		using (var entities = new <#= containerFullName #>())
		{
			var data = entities.<#=code.Escape(entity)#>;//Single(e => <# WriteKeyQueryParameters(entity, code); #> );
			Fetch(data);
		}//using
	}
<#
	}
#>
	private void Fetch(IEnumerable<<#=dataFullName#>> dataSet)
	{
		RaiseListChangedEvents = false;
		<# if(readOnly){#>IsReadOnly = false;<#}#>
		
		foreach (var data in dataSet)
			this.Add(<#=entityName#>.Get(data));
		<# if(readOnly){#>IsReadOnly = true;<#}#>
		RaiseListChangedEvents = true;

	}

	#endregion //Data Access

<#				
}//END LIST CREATE
#>
}
<#
		}
    }
    region.End();
	
#>

<#
    if (!String.IsNullOrEmpty(namespaceName))
    {
        PopIndent();
#>
}
<#
    }
    VerifyTypeUniqueness();
	
#>



<#+

    ////////
    //////// Write Key Criteria. 
    ////////
    private void WriteKeyCriteria(EntityType entity, CodeGenerationTools code)
    {
        MetadataTools ef = new MetadataTools(this);
#>
	private class KeyCriteria
	{
<#+
        PushIndent(CodeRegion.GetIndent(1));
		foreach (EdmProperty property in entity.KeyMembers)
        {
			WritePublicMember(property, code);
        }
		PopIndent();
#>
	
		internal KeyCriteria(<#+ WriteKeyParametersWithTypes(entity, code); #>)
		{
<#+
        PushIndent(CodeRegion.GetIndent(3));
		foreach (EdmProperty property in entity.KeyMembers)
			WriteLine(string.Format("this.{0} = {1};", property.Name, code.CamelCase(property.Name)));
		PopIndent();
#>
		}
	}
<#+
	}
	
#>


<#+

    ////////
    //////// Factory methods
    ////////
    private void WriteFactoryMethods(EntityType entity, CodeGenerationTools code)
    {
        MetadataTools ef = new MetadataTools(this);
		string entityFullName = code.Escape(entity.Name);
		string dataFullName = code.Escape(entityFullName);
#>
	public static <#=code.Escape(entityFullName)#>  New()
	{
		return DataPortal.Create<<#=entityFullName#>>();
	}
	
<#+
		if (entity.KeyMembers.Count > 0)
		{
#>

	public static <#=entityFullName#> Get(<#+ WriteKeyParametersWithTypes(entity, code); #>)
    {
    	return DataPortal.Fetch<<#=entityFullName#>>(new KeyCriteria(<#+ WriteKeyParameters(entity, code); #>));
	}
<#+
		}
#>
	internal static <#=entityFullName#> Get(<#=dataFullName#> data)
    {
    	return DataPortal.Fetch<<#=entityFullName#>>(data);
	}

<#+
	}
#>





<#+

    ////////
    //////// Write PrimitiveType Property. 
    ////////
    private void WritePrimitiveTypeProperty(EdmProperty primitiveProperty, bool readOnly, CodeGenerationTools code)
    {
        MetadataTools ef = new MetadataTools(this);
		string propertyName = code.Escape(primitiveProperty) + "Property";
#>
    <#=code.SpaceAfter(NewModifier(primitiveProperty))#><#=Accessibility.ForProperty(primitiveProperty)#> <#=code.Escape(primitiveProperty.TypeUsage)#> <#=code.Escape(primitiveProperty)#>
    {
        <#=code.SpaceAfter(Accessibility.ForGetter(primitiveProperty))#>get
        {
<#+             if (ef.ClrType(primitiveProperty.TypeUsage) == typeof(byte[]))
                {
#>
            return StructuralObject.GetValidValue(<#=code.FieldName(primitiveProperty)#>);
<#+
                }
                else
                {
#>
            return GetProperty(<#=propertyName#>);
<#+
                }
#>
        }
<#+ if (!readOnly) { #>
        <#=code.SpaceAfter(Accessibility.ForSetter((primitiveProperty)))#>set
        {
<#+
                if (ef.ClrType(primitiveProperty.TypeUsage) == typeof(byte[]))
                {
#>
            if (!StructuralObject.BinaryEquals(<#=code.FieldName(primitiveProperty)#>, value))
<#+
                }
                else 
                {
#>
            SetProperty(<#= propertyName #>, value);
<#+
                }
#>
<#+
        PushIndent(CodeRegion.GetIndent(1));
#>
<#+
        PopIndent();
#>
        }
<#+ } #>		
    }

<#+
    }

	////////
    //////// Write Navigation Property. 
    ////////
    private void WriteNavigationProperty(NavigationProperty property, bool readOnly, CodeGenerationTools code)
    {
        MetadataTools ef = new MetadataTools(this);
		string propertyName = code.Escape(property) + "Property";
#>
    <#=code.SpaceAfter(NewModifier(property))#><#=Accessibility.ForProperty(property)#> <#=code.Escape(property.TypeUsage)#> <#=code.Escape(property)#>
    {
        <#=code.SpaceAfter(Accessibility.ForGetter(property))#>get
        {
<#+             if (ef.ClrType(property.TypeUsage) == typeof(byte[]))
                {
#>
            return StructuralObject.GetValidValue(<#=code.FieldName(property)#>);
<#+
                }
                else
                {
#>
            return GetProperty(<#=propertyName#>);
<#+
                }
#>
        }
<#+ if (!readOnly) { #>
        <#=code.SpaceAfter(Accessibility.ForSetter((property)))#>set
        {
<#+
                if (ef.ClrType(property.TypeUsage) == typeof(byte[]))
                {
#>
            if (!StructuralObject.BinaryEquals(<#=code.FieldName(property)#>, value))
<#+
                }
                else 
                {
#>
            SetProperty(<#= propertyName #>, value);
<#+
			if (property.ToEndMember.RelationshipMultiplicity != RelationshipMultiplicity.Many)
			{

			AssociationType association = GetAssociationType(property.RelationshipType.Name);
			if (association != null)
			{
				//WriteLine("//" + association.Name);

#>
			if (value != null)
			{
<#+
		        PushIndent(CodeRegion.GetIndent(4));
				foreach (ReferentialConstraint constraint in association.ReferentialConstraints)
				{
					for (int i = 0; i < constraint.FromProperties.Count; i ++)
						WriteLine(string.Format("SetProperty({0}Property, value.{1});", constraint.ToProperties[i].Name, constraint.FromProperties[i].Name)); 
				}
				PopIndent();

#>
			}
			else
			{
<#+
		        PushIndent(CodeRegion.GetIndent(4));
				foreach (ReferentialConstraint constraint in association.ReferentialConstraints)
				{
					for (int i = 0; i < constraint.FromProperties.Count; i ++)
						WriteLine(string.Format("SetProperty({0}Property, null);", constraint.ToProperties[i].Name, constraint.FromProperties[i].Name)); 
				}
				PopIndent();
				
#>
			}
<#+
				
			}
			
			}
		
				}
#>
<#+
        PushIndent(CodeRegion.GetIndent(1));
#>
<#+
        PopIndent();
#>
        }
<#+ } #>		
    }

<#+
    }

	

	////////
    //////// Write Register Properties. 
    ////////
    private void WriteRegisterProperty(string propertyName, string typeName, CodeGenerationTools code)
    {
		//string propertyName = code.Escape(primitiveProperty);
		//string typeName = code.Escape(primitiveProperty.TypeUsage);
		WriteLine(string.Format("	private static PropertyInfo<{0}> {1}Property = RegisterProperty<{0}>(new PropertyInfo<{0}>(\"{1}\"));", typeName, propertyName));
    }

	////////
    //////// Write Register Properties. 
    ////////
    private void WritePublicMember(EdmProperty primitiveProperty, CodeGenerationTools code)
    {
        MetadataTools ef = new MetadataTools(this);
		Type propertyType = ef.ClrType(primitiveProperty.TypeUsage);
		
#>
	public <#=propertyType#> <#=code.Escape(primitiveProperty)#>;
<#+
    }

	
	////////
    //////// Write Register Properties. 
    ////////
    private void WriteKeyParametersWithTypes(EntityType entity, CodeGenerationTools code)
    {
        MetadataTools ef = new MetadataTools(this);
		if (entity.KeyMembers.Count == 0)
			return;
		int count=0;  
		foreach(EdmProperty property in entity.KeyMembers)
		{
			Type propertyType = ef.ClrType(property.TypeUsage);
			if(count>0)
				Write(", "); 
			Write(string.Format("{0} {1}", propertyType.Name, code.CamelCase(property.Name)));
			count++;
		}
    }

	////////
    //////// Write Register Properties. 
    ////////
    private void WriteKeyParameters(EntityType entity, CodeGenerationTools code)
    {
		if (entity.KeyMembers.Count == 0)
			return;
		int count=0;  
		foreach(EdmProperty property in entity.KeyMembers)
		{
			if(count>0)
				Write(", "); 
			Write(code.CamelCase(property.Name));
			count++;
		}
    }

	////////
    //////// Write Register Properties. 
    ////////
    private void WriteKeyQueryParameters(EntityType entity, CodeGenerationTools code)
    {
		if (entity.KeyMembers.Count == 0)
			return;
		int count=0;  
		foreach(EdmProperty property in entity.KeyMembers)
		{
			if(count>0)
				Write(" && "); 
			Write(string.Format("e.{0} == criteria.{0}", property.Name));
			count++;
		}
    }

	////////
    //////// Write Register Properties. 
    ////////
    private void WriteThisQueryParameters(EntityType entity, CodeGenerationTools code)
    {
		if (entity.KeyMembers.Count == 0)
			return;
		int count=0;  
		foreach(EdmProperty property in entity.KeyMembers)
		{
			if(count>0)
				Write(" && "); 
			Write(string.Format("e.{0} == this.{0}", property.Name));
			count++;
		}
    }

	
	////////
    //////// Write Register Properties. 
    ////////
    private void WriteLoadProperty(EdmMember property, CodeGenerationTools code)
    {
        MetadataTools ef = new MetadataTools(this);
		Type propertyType = ef.ClrType(property.TypeUsage);
		string fullType = string.Format("<{0}>", code.Escape(property.TypeUsage)); 
		
#>
		LoadProperty(<#=code.Escape(property)+ "Property, data." + code.Escape(property)#>);
<#+

	}
	
	////////
    //////// Write Register Properties. 
    ////////
    private void WriteReadProperty(EdmProperty primitiveProperty, CodeGenerationTools code)
    {
        MetadataTools ef = new MetadataTools(this);
		Type propertyType = ef.ClrType(primitiveProperty.TypeUsage);
		
		string fullType = string.Format("<{0}>", code.Escape(primitiveProperty.TypeUsage)); 
		
#>
		<#="data." + code.Escape(primitiveProperty)#> = ReadProperty(<#=code.Escape(primitiveProperty)+ "Property"#>);
<#+

	}

	
	
////////
//////// Declare Template Public Properties. 
////////
public string SourceCsdlPath{ get; set; }
public string ModelNamespace{ get; set; }
public EdmItemCollection ItemCollection{ get; set; }
public IEnumerable<string> ReferenceCsdlPaths{ get; set; }
public Nullable<bool> CreateContextAddToMethods{ get; set; }
public Dictionary<string, string> EdmToObjectNamespaceMap
{
    get { return _edmToObjectNamespaceMap; }
    set { _edmToObjectNamespaceMap = value; }
}
public Dictionary<string, string> _edmToObjectNamespaceMap = new Dictionary<string, string>();
public Double SourceEdmVersion
{
    get
    {
        if (ItemCollection != null)
        {
            return ItemCollection.EdmVersion;
        }

        return 0.0;
    }
}

////////
//////// Declare Template Private Properties. 
////////
static System.Resources.ResourceManager ResourceManager
{
    get
    {
        if (_resourceManager == null)
        {
            System.Resources.ResourceManager resourceManager = new System.Resources.ResourceManager("System.Data.Entity.Design", typeof(System.Data.Entity.Design.MetadataItemCollectionFactory).Assembly);
            System.Threading.Interlocked.CompareExchange(ref _resourceManager, resourceManager, null);
        }
        return _resourceManager;
    }
}
static System.Resources.ResourceManager _resourceManager;

private static string GetResourceString(string resourceName)
{
    return ResourceManager.GetString(resourceName,
         null); // Take default culture. 
}



private void VerifyTypeUniqueness()
{
    HashSet<string> hash = new HashSet<string>();
    IEnumerable<GlobalItem> allTypes = GetSourceSchemaTypes<GlobalItem>().Where(i => i is StructuralType || i is EntityContainer);

    foreach (GlobalItem type in allTypes)
    {
        if (!hash.Add(GetGlobalItemName(type)))
        {
            // 6034 is the error number used by System.Data.Entity.Design EntityClassGenerator. 
            Errors.Add(new System.CodeDom.Compiler.CompilerError(SourceCsdlPath, -1, -1, "6034",
             String.Format(CultureInfo.CurrentCulture,
                GetResourceString("Template_DuplicateTopLevelType"),
             GetGlobalItemName(type))));
        }
    }
}

protected string GetGlobalItemName(GlobalItem item)
{
    if (item is EdmType)
    {
        // EntityType or ComplexType. 
        return ((EdmType)item).Name;
    }
    else
    {
        // Must be an EntityContainer. 
        return ((EntityContainer)item).Name;
    }
}



void ApplyUserSettings(UserSettings userSettings)
{
    // Setup template UserSettings. 
    if (SourceCsdlPath == null)
    {
#if !PREPROCESSED_TEMPLATE
        if(userSettings.SourceCsdlPath == "$" + "edmxInputFile" + "$")
        {
            Errors.Add(new System.CodeDom.Compiler.CompilerError(Host.TemplateFile, 0, 0, "",
                GetResourceString("Template_ReplaceVsItemTemplateToken")));
            return;
        }

        SourceCsdlPath = Host.ResolvePath(userSettings.SourceCsdlPath);
#else
        SourceCsdlPath = userSettings.SourceCsdlPath;
#endif
    }

    // normalize the path, remove ..\ from it
    SourceCsdlPath = Path.GetFullPath(SourceCsdlPath);


    if (ReferenceCsdlPaths == null)
    {
        ReferenceCsdlPaths = userSettings.ReferenceCsdlPaths;
    }

    if (!CreateContextAddToMethods.HasValue)
    {
        CreateContextAddToMethods = userSettings.CreateContextAddToMethods;
    }

    DefaultSummaryComment = GetResourceString("Template_CommentNoDocumentation");
}


class UserSettings
{
    public string SourceCsdlPath{ get; set; }
    public string[] ReferenceCsdlPaths{ get; set; }
    public string LibraryNamespace{ get; set; }
    public string DataNamespace{ get; set; }
    public bool FullyQualifySystemTypes{ get; set; }
    public bool CreateContextAddToMethods{ get; set; }
    public bool CamelCaseFields{ get; set; }
}

string MultiSchemaEscape(TypeUsage usage, CodeGenerationTools code)
{
    StructuralType structural = usage.EdmType as StructuralType;
    if (structural != null)
    {
        return MultiSchemaEscape(structural, code);
    }
    return code.Escape(usage);
}

string MultiSchemaEscape(StructuralType type, CodeGenerationTools code)
{
    if (type.NamespaceName != ModelNamespace)
    {
        return code.CreateFullName(code.EscapeNamespace(GetObjectNamespace(type.NamespaceName)), code.Escape(type));
    }

    return code.Escape(type);
}

string NewModifier(NavigationProperty navigationProperty)
{
    Type baseType = typeof(EntityObject);
    return NewModifier(baseType, navigationProperty.Name);
}

string NewModifier(EdmFunction edmFunction)
{
    Type baseType = typeof(ObjectContext);
    return NewModifier(baseType, edmFunction.Name);
}

string NewModifier(EntitySet set)
{
    Type baseType = typeof(ObjectContext);
    return NewModifier(baseType, set.Name);
}

string NewModifier(EdmProperty property)
{
    Type baseType;
    if (property.DeclaringType.BuiltInTypeKind == BuiltInTypeKind.EntityType)
    {
        baseType = typeof(EntityObject);
    }
    else
    {
        baseType = typeof(ComplexObject);
    }
    return NewModifier(baseType, property.Name);
}

string NewModifier(Type type, string memberName)
{
    if (HasBaseMemberWithMatchingName(type, memberName))
    {
        return "new";
    }
    return string.Empty;
}

static bool HasBaseMemberWithMatchingName(Type type, string memberName)
{
    BindingFlags bindingFlags = BindingFlags.FlattenHierarchy | BindingFlags.NonPublic | BindingFlags.Public
                | BindingFlags.Instance | BindingFlags.Static;
    return type.GetMembers(bindingFlags).Where(m => IsVisibleMember(m)).Any(m => m.Name == memberName);
}

string ChangingMethodName(EdmMember member)
{
    return string.Format(CultureInfo.InvariantCulture, "On{0}Changing", member.Name);
}

string ChangedMethodName(EdmMember member)
{
    return string.Format(CultureInfo.InvariantCulture, "On{0}Changed", member.Name);
}

string InitializedTrackingField(EdmProperty property, CodeGenerationTools code)
{
    string namePart = property.Name + "Initialized";
    if (code.CamelCaseFields)
    {
        namePart = code.CamelCase(namePart);
    }
    return "_" + namePart;
}

string OptionalNullableParameterForSetValidValue(EdmMember member)
{
    MetadataTools ef = new MetadataTools(this);
    string list = string.Empty;
    if (((PrimitiveType)member.TypeUsage.EdmType).ClrEquivalentType.IsClass)
    {
        list += ", " + CreateLiteral(ef.IsNullable(member.TypeUsage));
    }
    return list;
}

static bool IsVisibleMember(MemberInfo memberInfo)
{
    if (memberInfo is EventInfo)
    {
        EventInfo ei = (EventInfo)memberInfo;
        MethodInfo add = ei.GetAddMethod();
        MethodInfo remove = ei.GetRemoveMethod();
        return IsVisibleMethod(add) || IsVisibleMethod(remove);
    }
    else if (memberInfo is FieldInfo)
    {
        FieldInfo fi = (FieldInfo)memberInfo;
        return !fi.IsPrivate && !fi.IsAssembly;
    }
    else if (memberInfo is MethodBase)
    {
        MethodBase mb = (MethodBase)memberInfo;
        if (mb.IsSpecialName)
            return false;
        return IsVisibleMethod(mb);
    }
    else if (memberInfo is PropertyInfo)
    {
        PropertyInfo pi = (PropertyInfo)memberInfo;
        MethodInfo get = pi.GetGetMethod();
        MethodInfo set = pi.GetSetMethod();
        return IsVisibleMethod(get) || IsVisibleMethod(set);
    }

    return false;
}

static bool IsVisibleMethod(MethodBase methodBase)
{
    if (methodBase == null)
        return false;

    return !methodBase.IsPrivate && !methodBase.IsAssembly;
}

IEnumerable<T> GetSourceSchemaTypes<T>() where T : GlobalItem
{
    if (Path.GetExtension(SourceCsdlPath) != ".edmx")
    {
        return ItemCollection.GetItems<T>().Where(e => e.MetadataProperties.Any(mp => mp.Name == "SchemaSource" && (string)mp.Value == SourceCsdlPath));
    }
    else
    {
        return ItemCollection.GetItems<T>();
    }
}

AssociationType GetAssociationType(string name)
{
	IEnumerable<AssociationType> associations = GetSourceSchemaTypes<AssociationType>().Where(i => i is AssociationType && i.Name == name);
	if (associations.Count() == 1)
		return associations.First();
	else
		return null;
}

string EndName(AssociationType association, int index)
{
    return association.AssociationEndMembers[index].Name;
}

string EndMultiplicity(AssociationType association, int index)
{
    return CreateLiteral(association.AssociationEndMembers[index].RelationshipMultiplicity);
}

string EscapeEndTypeName(AssociationType association, int index, CodeGenerationTools code)
{
    EntityType entity = association.AssociationEndMembers[index].GetEntityType();
    return code.CreateFullName(code.EscapeNamespace(GetObjectNamespace(entity.NamespaceName)), code.Escape(entity));
}

string GetObjectNamespace(string csdlNamespaceName)
{
    string objectNamespace;
    if (EdmToObjectNamespaceMap.TryGetValue(csdlNamespaceName, out objectNamespace))
    {
        return objectNamespace;
    }

    return csdlNamespaceName;
}

void UpdateObjectNamespaceMap(string objectNamespace)
{
	if(objectNamespace != ModelNamespace && !EdmToObjectNamespaceMap.ContainsKey(ModelNamespace))
	{
		EdmToObjectNamespaceMap.Add(ModelNamespace, objectNamespace);	
	}
}

static string FixParameterName(string name, CodeGenerationTools code)
{
    // Change any property that is 'id' (case insensitive) to 'ID' 
    // since 'iD' is a violation of FxCop rules. 
    if (StringComparer.OrdinalIgnoreCase.Equals(name, "id"))
    {
        // Return all lower case since it is an abbreviation, not an acronym. 
        return "id";
    }
    return code.CamelCase(name);
}

bool IncludePropertyInFactoryMethod(StructuralType factoryType, EdmProperty edmProperty)
{
    if (edmProperty.Nullable)
    {
        return false;
    }

    if (edmProperty.DefaultValue != null)
    {
        return false;
    }

    if ((Accessibility.ForReadOnlyProperty(edmProperty) != "public" && Accessibility.ForWriteOnlyProperty(edmProperty) != "public") ||
        (factoryType != edmProperty.DeclaringType && Accessibility.ForWriteOnlyProperty(edmProperty) == "private")
       )
    {
        // There is no public part to the property. 
        return false;
    }

    return true;
}

public enum CslaType
{
	EditableRoot,
	EditableChild,
	EditableChildList,
	ReadOnlyChild,
	ReadOnlyChildList,
	ReadOnlyRootList
}

public static CslaType GetCslaType(string name)
{
	return (CslaType)Enum.Parse(typeof(CslaType), name);
}

public static bool IsList(CslaType cslaType)
{
	if (cslaType.ToString().Contains("List"))
		return true;
	return false;
}

public static bool IsChild(CslaType cslaType)
{
	if (cslaType.ToString().Contains("Child"))
		return true;
	return false;
}

public static bool IsReadOnly(CslaType cslaType)
{
	if (cslaType.ToString().Contains("ReadOnly"))
		return true;
	return false;
}

private string GetBaseTypeName(EntityType entity, CslaType cslaType, CodeGenerationTools code)
{
	string entityName = getEntityName(entity, code);
	string listName = getListName(entity, code);
	if (IsReadOnly(cslaType))
	{
		if (IsList(cslaType))
			return string.Format("Csla.ReadOnlyListBase<{0}, {1}>", listName, entityName);
		else
			return string.Format("Csla.ReadOnlyBase<{0}>", entityName);
	}
	else
	{
		if (IsList(cslaType))
			return string.Format("Csla.BusinessListBase<{0}, {1}>", listName, entityName);
		else
			return string.Format("Csla.BusinessBase<{0}>", entityName);
	}
}

private string getName(EntityType entity, CslaType cslaType, CodeGenerationTools code)
{
	if (IsList(cslaType))
		return getListName(entity, code);
	else
		return getEntityName(entity, code);
}

private string getEntityName(EntityType entity, CodeGenerationTools code)
{
	return code.Escape(entity);
}

private string getListName(EntityType entity, CodeGenerationTools code)
{
	return string.Format("{0}List", code.Escape(entity));
}

private string GetFactoryMethodAccessibility(CslaType cslaType)
{
	if (IsChild(cslaType))
		return "internal";
	return "public";
}

private string GetFactoryMethodName(string name, CslaType cslaType)
{
	if (IsChild(cslaType))
		return string.Format("DataPortal.{0}Child", name);
	return string.Format("DataPortal.{0}", name);;
}

private string GetDataAccessMethodName(string name, CslaType cslaType)
{
	//Ako je create metoda ili je root objekt imamo protected override
	if (!IsChild(cslaType))
		return string.Format("DataPortal_{0}", name);
	else
		return string.Format("Child_{0}", name);
}

private string GetDataAccessMethodSignature(CslaType cslaType)
{
	//Ako je create metoda ili je root objekt imamo protected override
	if (!IsChild(cslaType))
		return "protected override void";
	else
		return "private void";
}


class FactoryMethodParameter
{
    public EdmProperty Source;
    public string RawParameterName;
    public string ParameterName;
    public string ParameterType;
    public string ParameterComment;
    public bool IsComplexType;

    public static IEnumerable<FactoryMethodParameter> CreateParameters(IEnumerable<EdmProperty> properties, UniqueIdentifierService unique, Func<TypeUsage, CodeGenerationTools, string> multiSchemaEscape, CodeGenerationTools code)
    {
        List<FactoryMethodParameter> parameters = new List<FactoryMethodParameter>();
        foreach (EdmProperty property in properties)
        {
            FactoryMethodParameter parameter = new FactoryMethodParameter();
            parameter.Source = property;
            parameter.IsComplexType = property.TypeUsage.EdmType is ComplexType;
            parameter.RawParameterName = unique.AdjustIdentifier(FixParameterName(property.Name, code));
            parameter.ParameterName = code.Escape(parameter.RawParameterName);
            parameter.ParameterType = multiSchemaEscape(property.TypeUsage, code);
            parameter.ParameterComment = String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_CommentFactoryMethodParam"), property.Name);
            parameters.Add(parameter);
        }

        return parameters;
    }
}

string DefaultSummaryComment{ get; set; }

string SummaryComment(MetadataItem item)
{
    if (item.Documentation != null && item.Documentation.Summary != null)
    {
        return PrefixLinesOfMultilineComment(XMLCOMMENT_START + " ", XmlEntityize(item.Documentation.Summary));
    }

    if (DefaultSummaryComment != null)
    {
        return DefaultSummaryComment;
    }

    return string.Empty;
}

string LongDescriptionCommentElement(MetadataItem item, int indentLevel)
{
    if (item.Documentation != null && !String.IsNullOrEmpty(item.Documentation.LongDescription))
    {
        string comment = Environment.NewLine;
        string lineStart = CodeRegion.GetIndent(indentLevel) + XMLCOMMENT_START + " ";
        comment += lineStart + "<LongDescription>" + Environment.NewLine;
        comment += lineStart + PrefixLinesOfMultilineComment(lineStart, XmlEntityize(item.Documentation.LongDescription)) + Environment.NewLine;
        comment += lineStart + "</LongDescription>";
        return comment;
    }
    return string.Empty;
}

string PrefixLinesOfMultilineComment(string prefix, string comment)
{
    return comment.Replace(Environment.NewLine, Environment.NewLine + prefix);
}

string ParameterComments(IEnumerable<Tuple<string, string>> parameters, int indentLevel)
{
    System.Text.StringBuilder builder = new System.Text.StringBuilder();
    foreach (Tuple<string, string> parameter in parameters)
    {
        builder.AppendLine();
        builder.Append(CodeRegion.GetIndent(indentLevel));
        builder.Append(XMLCOMMENT_START);
        builder.Append(String.Format(CultureInfo.InvariantCulture, " <param name=\"{0}\">{1}</param>", parameter.Item1, parameter.Item2));
    }
    return builder.ToString();
}

string XmlEntityize(string text)
{
    if (string.IsNullOrEmpty(text))
    {
        return string.Empty;
    }

    text = text.Replace("&","&amp;");
    text = text.Replace("<","&lt;").Replace(">","&gt;");
    string id = Guid.NewGuid().ToString();
    text = text.Replace(Environment.NewLine, id);
    text = text.Replace("\r", "&#xD;").Replace("\n","&#xA;");
    text = text.Replace(id, Environment.NewLine);
    return text.Replace("\'","&apos;").Replace("\"","&quot;");
}

const string XMLCOMMENT_START = "///";
IEnumerable<EdmProperty> GetProperties(StructuralType type)
{
    if (type.BuiltInTypeKind == BuiltInTypeKind.EntityType)
    {
        return ((EntityType)type).Properties;
    }
    else
    {
        return ((ComplexType)type).Properties;
    }
}
string CreateLiteral(object value)
{
    if (value == null)
    {
        return string.Empty;
    }

    Type type = value.GetType();
    if (type.IsEnum)
    {
        return type.FullName + "." + value.ToString();
    }
    if (type == typeof(Guid))
    {
        return string.Format(CultureInfo.InvariantCulture, "new Guid(\"{0}\")",
                             ((Guid)value).ToString("D", CultureInfo.InvariantCulture));
    }
    else if (type == typeof(DateTime))
    {
        return string.Format(CultureInfo.InvariantCulture, "new DateTime({0}, DateTimeKind.Unspecified)",
                             ((DateTime)value).Ticks);
    }
    else if (type == typeof(byte[]))
    {
        var arrayInit = string.Join(", ", ((byte[])value).Select(b => b.ToString(CultureInfo.InvariantCulture)).ToArray());
        return string.Format(CultureInfo.InvariantCulture, "new byte[] {{{0}}}", arrayInit);
    }
    else if (type == typeof(DateTimeOffset))
    {
        var dto = (DateTimeOffset)value;
        return string.Format(CultureInfo.InvariantCulture, "new DateTimeOffset({0}, new TimeSpan({1}))",
                             dto.Ticks, dto.Offset.Ticks);
    }

    var expression = new CodePrimitiveExpression(value);
    var writer = new StringWriter();
    CSharpCodeProvider code = new CSharpCodeProvider();
    code.GenerateCodeFromExpression(expression, writer, new CodeGeneratorOptions());
    return writer.ToString();
}

protected void VerifyGetterAndSetterAccessibilityCompatability(EdmMember member)
{
    string rawGetterAccessibility = Accessibility.ForReadOnlyProperty(member);
    string rawSetterAccessibility = Accessibility.ForWriteOnlyProperty(member);

    if ((rawGetterAccessibility == "internal" && rawSetterAccessibility ==   "protected") ||
        (rawGetterAccessibility == "protected" && rawSetterAccessibility == "internal"))

    {
           Errors.Add(new System.CodeDom.Compiler.CompilerError(SourceCsdlPath, -1, -1, "6033", String.Format(CultureInfo.CurrentCulture,
                   GetResourceString("GeneratedPropertyAccessibilityConflict"),
                       member.Name, rawGetterAccessibility, rawSetterAccessibility)));
    }
}

private void VerifyEntityTypeAndSetAccessibilityCompatability(EntitySet set)
{
    string typeAccess = Accessibility.ForType(set.ElementType);
    string setAccess = Accessibility.ForReadOnlyProperty(set);

    if(typeAccess == "internal" && (setAccess == "public" || setAccess == "protected"))
    {
       Errors.Add(new System.CodeDom.Compiler.CompilerError(SourceCsdlPath, -1, -1, "6036", String.Format(CultureInfo.CurrentCulture,
               GetResourceString("EntityTypeAndSetAccessibilityConflict"),
                   set.ElementType.Name, typeAccess, set.Name, setAccess)));
    }
}

////////
//////// UniqueIdentifierService 
////////
sealed class UniqueIdentifierService
{
    private readonly HashSet<string> _knownIdentifiers;

    public UniqueIdentifierService()
    {
        _knownIdentifiers = new HashSet<string>(StringComparer.Ordinal);
    }

    /// <summary>
    /// Makes the supplied identifier  unique within the scope by adding 
    /// a suffix (1, 2, 3, ...), and returns the unique identifier. 
    /// </summary>
    public string AdjustIdentifier(string identifier)
    {
        // find a unique name by adding suffix as necessary 
        var numberOfConflicts = 0;
        var adjustedIdentifier = identifier;

        while (!_knownIdentifiers.Add(adjustedIdentifier))
        {
            ++numberOfConflicts;
            adjustedIdentifier = identifier + numberOfConflicts.ToString(CultureInfo.InvariantCulture);
        }

        return adjustedIdentifier;
    }
}

#>
